<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Mint Pet Identity NFT</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Ethers v5 -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>

<body class="bg-gray-50 flex justify-center py-10">

<div class="bg-white shadow-xl rounded-2xl p-8 w-full max-w-2xl">

    <!-- æ ‡é¢˜ -->
    <h1 class="text-3xl font-bold text-gray-800 mb-1">ğŸ¶ Mint Your Pet Identity NFT</h1>
    <p class="text-gray-500 mb-6">Create a permanent on-chain identity for your pet.</p>

    <!-- Connect Wallet -->
    <button id="connectBtn"
            class="px-5 py-2 bg-indigo-600 text-white rounded-xl shadow hover:bg-indigo-700 transition">
        Connect Wallet
    </button>
    <p id="walletAddress" class="text-sm text-gray-600 mt-2"></p>

    <h2 class="text-xl font-bold mt-10 mb-3">ğŸ¾ My Pets</h2>
    <div id="myPetsContainer" class="space-y-4"></div>

    <hr class="my-6">

    <!-- Pet Info -->
    <h2 class="text-xl font-semibold text-gray-800 mb-3">ğŸ“ Pet Information</h2>

    <div class="grid grid-cols-2 gap-4">
        <input id="petName" placeholder="Pet Name" class="input">
        <input id="species" placeholder="Species (Dog / Cat)" class="input">
        <input id="breed" placeholder="Breed" class="input">
        <input id="birthday" type="date" class="input">
        <input id="traits" placeholder="Traits (Cute, Active...)" class="input">
        <input id="city" placeholder="City" class="input">
    </div>

    <!-- Upload Image -->
    <div class="mt-6">
        <p class="font-medium text-gray-700 mb-2">ğŸ“¸ Upload Pet Image</p>
        <input type="file" id="imageInput"
               class="block w-full text-sm text-gray-600 border border-gray-300 rounded-xl p-2 bg-white">
    </div>

    <!-- Mint Button -->
    <button id="mintBtn"
            class="w-full mt-8 py-3 text-white bg-green-600 rounded-xl shadow hover:bg-green-700 transition">
        Mint Pet NFT
    </button>

    <p id="status" class="mt-4 text-gray-700 text-center"></p>

    <hr class="my-8">

    <h2 class="text-2xl font-bold text-gray-800 mb-4">ğŸ“¸ Pet Moments</h2>
    <div class="space-y-4">
        <div>
            <p class="font-medium text-gray-700 mb-2">é€‰æ‹©æˆ‘çš„å® ç‰©</p>
            <select id="momentTokenSelect" class="input w-full">
                <option value="">è¯·å…ˆè¿æ¥é’±åŒ…å¹¶é€‰æ‹©å® ç‰©</option>
            </select>
        </div>

        <div id="selectedPetInfo" class="bg-gray-50 border border-dashed border-gray-300 rounded-2xl p-4 text-gray-600 text-sm">
            Connect wallet to load your pet information.
        </div>

        <div class="bg-white border border-gray-200 rounded-2xl p-4">
            <p class="font-semibold text-gray-800 mb-3">å‘å¸ƒæ–°çš„æ—¶åˆ»</p>
            <div class="space-y-3">
                <input type="file" id="momentImageInput"
                       class="block w-full text-sm text-gray-600 border border-gray-300 rounded-xl p-2 bg-white">
                <textarea id="momentDescription" rows="3"
                          class="w-full text-sm text-gray-700 border border-gray-300 rounded-xl p-3 bg-gray-50"
                          placeholder="è®°å½•å® ç‰©æ­¤åˆ»çš„å°æ•…äº‹..."></textarea>
                <button id="publishMomentBtn"
                        class="w-full py-3 text-white bg-indigo-600 rounded-xl shadow hover:bg-indigo-700 transition">
                    å‘å¸ƒæ—¶åˆ»
                </button>
                <p id="momentStatus" class="text-sm text-gray-600"></p>
            </div>
        </div>

        <div>
            <p class="font-semibold text-gray-800 mb-3 flex items-center gap-2">
                Moments Gallery
                <span class="text-sm text-gray-500">(é“¾ä¸Šå¯éªŒè¯)</span>
            </p>
            <div id="momentsGrid" class="grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
        </div>
    </div>

    <div id="uploadTestWrapper" class="hidden">
        <hr class="my-8">

        <h2 class="text-xl font-semibold text-gray-800 mb-3">ğŸ”§ Upload API Test</h2>

        <div class="space-y-4">
            <div class="bg-gray-50 p-4 rounded-xl border border-gray-200">
                <p class="font-medium text-gray-700 mb-2">æµ‹è¯•ä¸Šä¼ ç…§ç‰‡</p>
                <input type="file" id="testImageInput"
                       class="block w-full mb-3 text-sm text-gray-600 border border-gray-300 rounded-xl p-2 bg-white">
                <button id="testImageBtn"
                        class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition text-sm">
                    ä¸Šä¼ ç…§ç‰‡æµ‹è¯•
                </button>
                <p id="testImageResult" class="text-xs text-gray-600 mt-2 break-words"></p>
            </div>

            <div class="bg-gray-50 p-4 rounded-xl border border-gray-200">
                <p class="font-medium text-gray-700 mb-2">æµ‹è¯•ä¸Šä¼ å…ƒæ•°æ®(JSON)</p>
                <textarea id="testMetadataInput" rows="4"
                          class="w-full text-sm text-gray-700 border border-gray-300 rounded-xl p-2 bg-white"
                          placeholder='{"name": "Demo Pet"}'></textarea>
                <button id="testMetadataBtn"
                        class="mt-3 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition text-sm">
                    ä¸Šä¼ å…ƒæ•°æ®æµ‹è¯•
                </button>
                <p id="testMetadataResult" class="text-xs text-gray-600 mt-2 break-words"></p>
            </div>
        </div>
    </div>

</div>

<div id="momentModal" class="hidden fixed inset-0 bg-black/50 z-10 flex items-center justify-center px-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full p-6 relative max-h-[90vh] overflow-auto">
        <button id="closeMomentModal" class="absolute right-4 top-4 text-gray-500 hover:text-gray-800 text-xl">&times;</button>
        <img id="modalMomentImage" class="w-full rounded-xl object-contain max-h-[70vh] mb-4 bg-gray-100" src="" alt="Moment detail">
        <p id="modalMomentDescription" class="text-gray-800 mb-2"></p>
        <p id="modalMomentTime" class="text-sm text-gray-500"></p>
    </div>
</div>

<!-- è‡ªå®šä¹‰ Input æ ·å¼ -->
<style>
    .input {
        padding: 10px;
        border-radius: 12px;
        border: 1px solid #ddd;
        background: #fafafa;
        outline: none;
    }

    .input:focus {
        border-color: #6366f1;
        background: white;
        box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }
</style>

<script>
    const CONTRACT_ADDRESS = "0x055acbcD634EFb87FF6819084527200A64846a31";
    const PET_MOMENTS_ADDRESS = "0x514D64EB785724B932547BFE0ef8F12d3a533A47";
    const PINATA_JWT = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJlZjk1ZWRhZS0zOTE2LTQyZDgtODRhMy0xZDU2YjdmZGY2MGEiLCJlbWFpbCI6ImJvd3V0aW5nQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJwaW5fcG9saWN5Ijp7InJlZ2lvbnMiOlt7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6IkZSQTEifSx7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6Ik5ZQzEifV0sInZlcnNpb24iOjF9LCJtZmFfZW5hYmxlZCI6ZmFsc2UsInN0YXR1cyI6IkFDVElWRSJ9LCJhdXRoZW50aWNhdGlvblR5cGUiOiJzY29wZWRLZXkiLCJzY29wZWRLZXlLZXkiOiI0Mzk1YmJkOWI2MTQ2NzAzZDJjNCIsInNjb3BlZEtleVNlY3JldCI6ImQyNDUzM2I5ZTJjOTJkN2Y3ODliYmJhYTBlN2E2NzI2ZTJiYjhhNzIyYTIxMzY2MDM0YTY5ZDA1Y2VjYjM4MDgiLCJleHAiOjE3OTUwNzE5MTV9.IrG3zq0gyqJ-7u9opkfhXSItbf20KW5aUAz8EJqmVLY";
    const PINATA_FILE_ENDPOINT = "https://api.pinata.cloud/pinning/pinFileToIPFS";
    const PINATA_METADATA_ENDPOINT = "https://api.pinata.cloud/pinning/pinJSONToIPFS";
    const ABI = [
        "function mintPet(string,string,string,uint64,string,string,string) external returns (uint256)",
        "function tokenURI(uint256) view returns (string)",
        "event PetMinted(uint256 indexed petId, address indexed owner)"
    ];
    const PET_MOMENTS_ABI = [
        "function addMoment(uint256,string,string) external",
        "function getAllMoments(uint256) view returns (tuple(string imageURI,string description,uint64 timestamp)[])"
    ];

    const momentTokenSelect = document.getElementById("momentTokenSelect");
    const selectedPetInfo = document.getElementById("selectedPetInfo");
    const momentImageInput = document.getElementById("momentImageInput");
    const momentDescriptionInput = document.getElementById("momentDescription");
    const momentStatus = document.getElementById("momentStatus");
    const momentsGrid = document.getElementById("momentsGrid");
    const momentModal = document.getElementById("momentModal");
    const modalMomentImage = document.getElementById("modalMomentImage");
    const modalMomentDescription = document.getElementById("modalMomentDescription");
    const modalMomentTime = document.getElementById("modalMomentTime");

    let provider, signer, contract, petMomentsContract;
    let myPetIds = [];
    let currentTokenId = "";
    let currentMoments = [];

    // Connect Wallet
    document.getElementById("connectBtn").onclick = async function () {
        if (!window.ethereum) return alert("Install MetaMask!");

        await ethereum.request({ method: "eth_requestAccounts" });

        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();

        contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
        petMomentsContract = new ethers.Contract(PET_MOMENTS_ADDRESS, PET_MOMENTS_ABI, signer);

        document.getElementById("walletAddress").innerHTML =
            "Connected: " + await signer.getAddress();

        await renderMyPets();
    };

    // Load all NFTs owned by current user
    async function loadMyPets() {
        if (!signer || !contract) return [];

        const address = await signer.getAddress();
        const filter = contract.filters.PetMinted(null, address);
        const logs = await contract.queryFilter(filter);

        return logs.map(log => log.args.petId.toString());
    }

    // Render pet cards
    async function renderMyPets() {
        const container = document.getElementById("myPetsContainer");
        if (!container) return;

        if (!contract) {
            container.innerHTML = "<p class=\"text-gray-500 text-sm\">Connect wallet to load your pets.</p>";
            return;
        }

        container.innerHTML = "Loadingâ€¦";

        try {
            const petIds = await loadMyPets();
            if (petIds.length === 0) {
                container.innerHTML = "<p>No pets found.</p>";
                myPetIds = [];
                populateMomentSelect();
                updateSelectedPet(null, null);
                return;
            }

            myPetIds = petIds;
            populateMomentSelect();

            let html = "";

            for (let id of petIds) {
                const metaJson = await fetchTokenMetadata(id);

                html += `
            <div class="p-4 bg-white rounded-xl shadow flex gap-4 items-center">
                <img src="${ipfsToHttp(metaJson.image)}"
                     class="w-20 h-20 rounded-lg object-cover" />
                <div>
                    <p class="font-bold text-lg">${metaJson.name}</p>
                    <p class="text-gray-600 text-sm">Token ID: ${id}</p>
                </div>
            </div>
        `;
            }

            container.innerHTML = html;
        } catch (err) {
            console.error(err);
            container.innerHTML = "<p class=\"text-red-500\">Failed to load pets.</p>";
        }
    }

    function ensurePinataJwt() {
        if (!PINATA_JWT || PINATA_JWT === "PASTE_YOUR_PINATA_JWT_HERE") {
            throw new Error("è¯·åœ¨é¡µé¢é¡¶éƒ¨é…ç½® Pinata JWT");
        }
    }

    async function pinataFetch(endpoint, options = {}) {
        ensurePinataJwt();
        const headers = {
            ...(options.headers || {}),
            Authorization: `Bearer ${PINATA_JWT}`
        };

        const response = await fetch(endpoint, {
            ...options,
            headers
        });

        let data = null;
        const text = await response.text();
        if (text) {
            try {
                data = JSON.parse(text);
            } catch (err) {
                throw new Error("Pinata è¿”å›é JSON æ•°æ®");
            }
        }

        if (!response.ok) {
            const message = data && (data.error || data.message);
            throw new Error(message || "Pinata API è¯·æ±‚å¤±è´¥");
        }

        if (!data) {
            throw new Error("Pinata è¿”å›ç©ºå“åº”");
        }

        return data;
    }

    // Upload Image
    async function uploadImageToPinata(file) {
        const formData = new FormData();
        formData.append("file", file);

        const data = await pinataFetch(PINATA_FILE_ENDPOINT, {
            method: "POST",
            body: formData
        });

        if (!data.IpfsHash) {
            throw new Error("Pinata upload missing IpfsHash");
        }

        return `ipfs://${data.IpfsHash}`;
    }

    function ipfsToHttp(uri) {
        return uri ? uri.replace("ipfs://", "https://ipfs.io/ipfs/") : "";
    }

    async function fetchTokenMetadata(tokenId) {
        const tokenURI = await contract.tokenURI(tokenId);
        const metadata = await fetch(ipfsToHttp(tokenURI));
        return metadata.json();
    }

    function populateMomentSelect() {
        if (!momentTokenSelect) return;
        const previousSelection = momentTokenSelect.value;

        momentTokenSelect.innerHTML = "";

        if (!myPetIds.length) {
            momentTokenSelect.innerHTML = '<option value="">æš‚æ— å¯ç”¨å® ç‰©</option>';
            currentTokenId = "";
            momentsGrid.innerHTML = '<p class="text-sm text-gray-500">æš‚æœªé€‰æ‹©å® ç‰©</p>';
            return;
        }

        momentTokenSelect.innerHTML = '<option value="">é€‰æ‹©è¦æŸ¥çœ‹çš„å® ç‰©</option>';
        myPetIds.forEach(id => {
            const opt = document.createElement("option");
            opt.value = id;
            opt.textContent = `Token #${id}`;
            momentTokenSelect.appendChild(opt);
        });

        const defaultId = myPetIds.includes(previousSelection) ? previousSelection : myPetIds[0];
        momentTokenSelect.value = defaultId || "";
        if (defaultId) {
            handleTokenSelection(defaultId);
        }
    }

    async function handleTokenSelection(tokenId) {
        currentTokenId = tokenId;
        if (!tokenId) {
            updateSelectedPet(null, null);
            momentsGrid.innerHTML = '<p class="text-sm text-gray-500">è¯·é€‰æ‹©å® ç‰©æŸ¥çœ‹æ›´å¤šå†…å®¹ã€‚</p>';
            return;
        }

        try {
            selectedPetInfo.innerHTML = "Loading metadataâ€¦";
            const meta = await fetchTokenMetadata(tokenId);
            updateSelectedPet(meta, tokenId);
            await renderMoments(tokenId);
        } catch (err) {
            console.error(err);
            selectedPetInfo.innerHTML = '<p class="text-red-500 text-sm">åŠ è½½å® ç‰©ä¿¡æ¯å¤±è´¥</p>';
        }
    }

    function updateSelectedPet(meta, tokenId) {
        if (!selectedPetInfo) return;

        if (!meta || !tokenId) {
            selectedPetInfo.innerHTML = '<p class="text-gray-500 text-sm">è¯·é€‰æ‹©å® ç‰©æŸ¥çœ‹è¯¦æƒ…ã€‚</p>';
            return;
        }

        selectedPetInfo.innerHTML = `
            <div class="flex gap-4 items-center">
                <img src="${ipfsToHttp(meta.image)}" class="w-24 h-24 rounded-2xl object-cover">
                <div>
                    <p class="text-lg font-bold text-gray-800">${meta.name}</p>
                    <p class="text-sm text-gray-600">Token ID: ${tokenId}</p>
                    <p class="text-sm text-gray-600">${meta.description || ""}</p>
                </div>
            </div>
        `;
    }

    async function renderMoments(tokenId) {
        if (!momentsGrid) return;
        if (!petMomentsContract) {
            momentsGrid.innerHTML = '<p class="text-sm text-gray-500">è¯·å…ˆè¿æ¥é’±åŒ…</p>';
            return;
        }

        momentsGrid.innerHTML = '<p class="text-sm text-gray-500">Loading momentsâ€¦</p>';

        try {
            const moments = await loadMoments(tokenId);
            currentMoments = moments;

            if (!moments.length) {
                momentsGrid.innerHTML = '<p class="text-sm text-gray-500">æš‚æ— æ—¶åˆ»ï¼Œå¿«æ¥å‘å¸ƒç¬¬ä¸€æ¡å§ï¼</p>';
                return;
            }

            let html = "";
            moments.forEach((moment, index) => {
                html += `
                    <div class="bg-white rounded-2xl shadow hover:shadow-lg transition cursor-pointer" data-moment-index="${index}">
                        <div class="w-full bg-gray-100 rounded-t-2xl overflow-hidden flex items-center justify-center">
                            <img src="${ipfsToHttp(moment.imageURI)}" class="w-full max-h-80 object-contain">
                        </div>
                        <div class="p-4">
                            <p class="text-gray-800 font-medium truncate">${moment.description || "æ— æè¿°"}</p>
                            <p class="text-xs text-gray-500 mt-1">${formatTimestamp(moment.timestamp)}</p>
                        </div>
                    </div>
                `;
            });

            momentsGrid.innerHTML = html;
            momentsGrid.querySelectorAll("[data-moment-index]").forEach(card => {
                card.addEventListener("click", () => {
                    const idx = parseInt(card.getAttribute("data-moment-index"), 10);
                    openMomentModal(currentMoments[idx]);
                });
            });
        } catch (err) {
            console.error(err);
            momentsGrid.innerHTML = '<p class="text-sm text-red-500">åŠ è½½ Moments å¤±è´¥</p>';
        }
    }

    async function loadMoments(tokenId) {
        if (!petMomentsContract) return [];
        const moments = await petMomentsContract.getAllMoments(tokenId);
        return moments.map(m => ({
            imageURI: m.imageURI,
            description: m.description,
            timestamp: m.timestamp.toNumber ? m.timestamp.toNumber() : Number(m.timestamp)
        }));
    }

    function formatTimestamp(ts) {
        if (!ts) return "";
        return new Date(Number(ts) * 1000).toLocaleString();
    }

    function openMomentModal(moment) {
        if (!moment) return;
        modalMomentImage.src = ipfsToHttp(moment.imageURI);
        modalMomentDescription.textContent = moment.description || "æ— æè¿°";
        modalMomentTime.textContent = formatTimestamp(moment.timestamp);
        momentModal.classList.remove("hidden");
    }

    function closeMomentModal() {
        momentModal.classList.add("hidden");
    }

    const closeMomentModalBtn = document.getElementById("closeMomentModal");
    if (closeMomentModalBtn) {
        closeMomentModalBtn.addEventListener("click", closeMomentModal);
    }
    if (momentModal) {
        momentModal.addEventListener("click", function (event) {
            if (event.target === momentModal) {
                closeMomentModal();
            }
        });
    }

    if (momentTokenSelect) {
        momentTokenSelect.addEventListener("change", async function () {
            await handleTokenSelection(this.value);
        });
    }

    document.getElementById("publishMomentBtn").onclick = async function () {
        if (!petMomentsContract) return alert("è¯·å…ˆè¿æ¥é’±åŒ…");

        const tokenId = momentTokenSelect.value;
        if (!tokenId) return alert("è¯·é€‰æ‹©ä¸€ä¸ªå® ç‰©");

        const file = momentImageInput.files[0];
        if (!file) return alert("è¯·ä¸Šä¼ æ—¶åˆ»ç…§ç‰‡");

        const description = momentDescriptionInput.value.trim();
        if (!description) return alert("è¯·å¡«å†™æè¿°");

        try {
            momentStatus.innerHTML = "ä¸Šä¼ å›¾ç‰‡ä¸­â€¦";
            const imageURI = await uploadImageToPinata(file);

            momentStatus.innerHTML = "æäº¤åŒºå—é“¾äº¤æ˜“â€¦";
            const tx = await petMomentsContract.addMoment(tokenId, imageURI, description);
            await tx.wait();

            momentStatus.innerHTML = "âœ… å‘å¸ƒæˆåŠŸï¼";
            momentImageInput.value = "";
            momentDescriptionInput.value = "";

            await renderMoments(tokenId);
        } catch (err) {
            console.error(err);
            momentStatus.innerHTML = "âŒ å‘å¸ƒå¤±è´¥ï¼š" + err.message;
        }
    };

    // Upload metadata
    async function uploadMetadata(metadata) {
        const data = await pinataFetch(PINATA_METADATA_ENDPOINT, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(metadata)
        });

        if (!data.IpfsHash) {
            throw new Error("Pinata upload missing IpfsHash");
        }

        return `ipfs://${data.IpfsHash}`;
    }

    // Mint
    document.getElementById("mintBtn").onclick = async function () {
        try {
            const name = petName.value;
            const speciesValue = species.value;
            const breedValue = breed.value;
            const traitsValue = traits.value;
            const cityValue = city.value;

            const birthdayTimestamp = Math.floor(new Date(birthday.value).getTime() / 1000);
            const file = imageInput.files[0];
            if (!file) return alert("Please upload an image!");

            status.innerHTML = "Uploading imageâ€¦";
            const imageCID = await uploadImageToPinata(file);

            const metadata = {
                name,
                description: "Pet identity NFT",
                image: imageCID,
                attributes: [
                    { trait_type: "Species", value: speciesValue },
                    { trait_type: "Breed", value: breedValue },
                    { trait_type: "Birthday", value: birthdayTimestamp },
                    { trait_type: "Traits", value: traitsValue },
                    { trait_type: "City", value: cityValue }
                ]
            };

            status.innerHTML = "Uploading metadataâ€¦";
            const metadataCID = await uploadMetadata(metadata);

            status.innerHTML = "Minting NFT on Baseâ€¦";

            const tx = await contract.mintPet(
                name,
                speciesValue,
                breedValue,
                birthdayTimestamp,
                traitsValue,
                cityValue,
                metadataCID
            );

            await tx.wait();

            status.innerHTML = "ğŸ‰ Mint Success! Transaction: " + tx.hash;
            await renderMyPets();

        } catch (err) {
            status.innerHTML = "âŒ Error: " + err.message;
            console.error(err);
        }
    };

    document.getElementById("testImageBtn").onclick = async function () {
        const file = testImageInput.files[0];
        if (!file) return alert("è¯·å…ˆé€‰æ‹©ç…§ç‰‡");

        testImageResult.innerHTML = "ä¸Šä¼ ä¸­...";
        try {
            const cid = await uploadImageToPinata(file);
            testImageResult.innerHTML = "æˆåŠŸ: " + cid;
        } catch (err) {
            console.error(err);
            testImageResult.innerHTML = "å¤±è´¥: " + err.message;
        }
    };

    document.getElementById("testMetadataBtn").onclick = async function () {
        let json;
        try {
            json = JSON.parse(testMetadataInput.value || "{}");
        } catch (err) {
            return alert("è¯·è¾“å…¥åˆæ³•çš„ JSON");
        }

        testMetadataResult.innerHTML = "ä¸Šä¼ ä¸­...";
        try {
            const cid = await uploadMetadata(json);
            testMetadataResult.innerHTML = "æˆåŠŸ: " + cid;
        } catch (err) {
            console.error(err);
            testMetadataResult.innerHTML = "å¤±è´¥: " + err.message;
        }
    };
</script>
</body>
</html>
